use eframe::egui;
use inputbot::KeybdKey;
use std::sync::{Arc, Mutex};
use strum::IntoEnumIterator;

mod map;

const PRINT: bool = true;

fn main() {
    let current_key = Arc::new(Mutex::new(String::from("hello world")));

    let key_for_gui = current_key.clone();
    let _ = std::thread::spawn(move || {
        key_presses(key_for_gui.clone());
    });

    let _ = gui_window(current_key.clone());
}

fn key_presses(current_key: Arc<Mutex<String>>) {
    for key in KeybdKey::iter() {
        let current_key = current_key.clone();
        key.bind(move || {
            press(current_key.clone(), &key);
        });
    }

    inputbot::handle_input_events();
}

fn press(current_key: Arc<Mutex<String>>, key: &KeybdKey) {
    let key_string = map::key_to_string(key);
    if PRINT {
        println!("pressed \"{}\"", key_string);
    }
    {
        let mut current_key = current_key.lock().unwrap();
        *current_key = key_string.to_owned();
    }
}

fn gui_window(current_key: Arc<Mutex<String>>) -> eframe::Result {
    let gui_app = GuiApp {
        current_key: current_key.clone(),
    };
    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default().with_inner_size([320.0, 240.0]),
        ..Default::default()
    };
    eframe::run_native("KBD", options, Box::new(|_cc| Ok(Box::new(gui_app))))
}

struct GuiApp {
    current_key: Arc<Mutex<String>>,
}
impl eframe::App for GuiApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
            ui.label("hi");
            ui.label(format!("{}", self.current_key.lock().unwrap()));
        });
    }
}
